VIAORA = $6001 ; VIA OUTPUT REGISTER A
VIADDRA = $6003 ; VIA DATA DIRECTION REGISTER A
VIAORB = $6000 ; VIA OUTPUT REGISTER B
VIADDRB = $6002 ; VIA DATA DIRECTION REGISTER B
VI2ORA = $5001 ; VIA 2 ORA
VI2DDRA = $5003 ; VIA 2 DDRA
VI2ORB = $5000 ; VIA 2 ORB
VI2DDRB = $5002 ; VIA 2 DDRB]
VI2PCR = $500C ; VIA2 HANDSHAKE
ACIA_DATA = $4400
ACIA_STATUS = $4401
ACIA_COMMAND = $4402
ACIA_CONTROL = $4403
RAMD1 = $2000
RAMD2 = $2001


; THE FOLLOWING IS AN PLAY VGA IN ROM
; *** WE'RE ASSUMING THAT THIS PROGRAM WAS CALLED FROM THE MONITOR ***
; ***       MEANING THAT ACIA HAS ALREADY BEEN INIT 19200 8,N,1    ***

;  ******** VGM NOTES ***********
;  0x61 nn nn : Wait n samples, n can range from 0 to 65535 (approx 1.49
;               seconds). Longer pauses than this are represented by multiple
;               wait commands.
;  0x62       : wait 735 samples (60th of a second), a shortcut for
;               0x61 0xdf 0x02
;  0x63       : wait 882 samples (50th of a second), a shortcut for
;               0x61 0x72 0x03
 
 
; WORKS RIGHT NOW WITH VGM FILES THAT ARE UNCOMPRESSED, FROM DEFLEMASK ONLY
; THIS IS BECAUSE I HAVENT IMPLEMENTED THE 0x7N DELAY COMMANDS YET 
;
;

  *=$0090
 
MUSIC: .DS $4 ; VGM DATA POINTER
DELAYC1: .DS $1
DELAYC2: .DS $1
DELAYC3: .DS $1
COUNTER = $0300
DELAY = $4000
MUSICDUMMY: .DS $2
MUSIC1: .DS $1
MUSIC2: .DS $1
MAINDELAY = $2000
FAKEMUSIC: .DS $4
FAKEMUSICDUMMY: .DS $2 
SIX2DELAYIN: .DS $2
SIX2DELAYIN2: .DS $2
SIX3DELAYIN: .DS $2
SIX3DELAYIN2: .DS $2
 
  *=$8600
 

PREP: LDA #$00
      STA MUSIC
      LDA #$89
      STA MUSIC+1 		; SETS VGM DATA POINTER TO ADDRESS $00 $89 ($8900)
      LDA #@00000111
      STA VIAORB
      LDY #$00
      
VGMSTART: 
       
       LDA (MUSIC) 		; LOAD ACC WITH DATA REFERENCED BY MUSIC (EX, 8900 AT THE START)
       CMP #$50 
       BEQ PROCESSNX 		; 0X50 IS THE VGM COMMAND FOR PROCESSING THE VERY NEXT DATA BYTE. ONLY BYTES AFTER A 0X50 SHOULD BE WRITTEN TO THE CHIP AND PROCESSE
       CMP #$61 		; DELAY 0X61 XX XX , XX XX BEING NUMBER OF SAMPLES
       BEQ DELAYCOUNT
       CMP #$62 		; SHORTCUT FOR 0X61 0XDF 0X02
       BEQ SIX22
       CMP #$63
       BEQ SIX33 		; SHORTCUT FOR 0X72 0X03
       CMP #$66
       BEQ SIX66
       JMP SEVDELAY

SIX22: 
       LDA #$DF 		; INDIRECTLY LOAD DF AT 3000. DONE THIS WAY SO SHORTCUT DELAYS TAKE SAME AMOUNT OF CLOCK CYCLES AS COUNTING DELAYS
       STA MUSIC2
       LDA #$02 		; INDIRECTLY LOAD 02 AT 3001. 
       STA MUSIC1
       JSR GENDELAY
       JMP VGMSTART
SIX33:
       LDA #$72 		; INDIRECTLY LOAD 72 AT 3002 
       STA MUSIC2
       LDA #$03 		; INDIRECTLY LOAD 03 AT 3003
       STA MUSIC1
       JSR GENDELAY
       JMP VGMSTART
SIX66:
       JMP PREP			; 0x66 marks end of file. Restart. 

SEVDELAY
       JSR ADD
       JMP VGMSTART		; SKIPS 7X DELAY COMMANDS FOR NOW. 
       
DELAYCOUNT: 
          JSR ADD
          LDA (MUSIC)
          STA MUSIC2
          JSR ADD
          LDA (MUSIC)
          STA MUSIC1
          JSR GENDELAY
          JMP VGMSTART

PROCESSNX: ; SENDS DATA BYTE TO SN, WRITES IT IN
   
      JSR ADD
RDY   LDA (MUSIC)
      STA VI2ORB
      JSR PULSE
      JSR ADD
      JMP VGMSTART

          
GENDELAY ; CONSTANT DELAY I GUESS

 STZ COUNTER
 STZ COUNTER+1
 PHA
 



NXDELAY   LDX MAINDELAY				 ; 16 bit delay counter. EX: 61 DF 02 WILL REPEAT THIS LOOP $02DF TIMES
DELAY8    DEX
          BNE DELAY8 ; A SMALL CONSTANT DELAY
          LDA COUNTER ; IS HIGH BYTE 02?
          CMP MUSIC1 ; 
          BEQ CHECK ; IT IS. CHECK TO SEE IF LOW BYTE IS DF 
CHECKFAIL LDA COUNTER+1 ; 
          CMP #$FF ; IS LOW BYTE FULL?
          BEQ NEXTONE ; YES. RESET IT AND INCREMENT HIGH BYTE
          CLC
          LDA COUNTER+1 ; IT ISN'T. ADD INCREMENT LOW BYTE. 
          ADC #1
          STA COUNTER+1
          JMP NXDELAY
        
NEXTONE ; INCREMENTS HIGH BYTE IN COUNTER UP ONE
       
      CLC
      LDA COUNTER
      ADC #1
      STA COUNTER 
      STZ COUNTER+1
        
        
CHECK ; HIGH BYTE IS 02. CHECK LOW BYTE
      LDA COUNTER+1
      CMP MUSIC2 ; IS LOW BYTE DF?
      BNE CHECKFAIL ; IT ISN'T. CONTINUE LOOP
      PLA
      JSR ADD ; IT IS. WE'RE DONE DELAYING. MOVE TO THE NEXT BYTE AND REPEAT THE PARSING. 
      RTS


ADD: ; MOVES ADDRESS UP ONE
      
      CLC
      LDA MUSIC
      CMP #$FF
      BEQ ADD2
      ADC #1
      STA MUSIC
      JSR DUMMYADD2
      RTS

ADD2: ; MOVES ADDRESS UP ONE
      
      LDA #$00
      STA MUSIC
      CLC
      LDA MUSIC+1
      ADC #1
      STA MUSIC+1 
      RTS
DUMMYADD2

      LDA #$00
      STA MUSICDUMMY
      CLC
      LDA MUSICDUMMY+1
      ADC #1
      STA MUSICDUMMY+1
      RTS
      
      
PULSE: ; PULSES WE FOR SN76489

       LDA #@00000111
       STA VIAORB
       LDA #@00000011
       STA VIAORB
       JSR MANUALDELAY
       LDA #@00000111
       STA VIAORB
       RTS
       
       
MANUALDELAY: ; I have no clue how or why I did this. 
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 NOP
 RTS           